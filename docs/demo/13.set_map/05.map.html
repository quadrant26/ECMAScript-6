<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Map</title>
</head>
<body>
<script>

var m = new Map();
var o = {p : "hello, world"};

m.set(o, "content");
console.log( m.get(o) );  // content
console.log(m.has(o));      // true
m.delete(o)
console.log(m.has(o));      // false

var m1 = new Map([['name', '张三'], ['title', 'Author']]);

console.log(m1.size); // 2
console.log(m1.has('name')); // true
console.log(m1.get('name')); // 张三
console.log(m1.has('title')); // true
console.log(m1.get('title')); // Author

// 如果对同一个键多次赋值，后面的值将覆盖前面的值
m1.set(1, "add").set(1, "bbb");
console.log(m1.get(1));

// 如果读取一个未知的键，则返回 undefined
console.log(new Map().get(23));  // undefined 

// 只有对同一个对象的引用，Map结构才将其视为同一个键
var map2 = new Map();

map2.set(['a'], 555);
map2.get(['a']) // undefined
// 上面代码的set和get方法，表面是针对同一个键，但实际上这是两个值，内存地址是不一样的，因此get方法无法读取该键，返回undefined

// 同样的值的两个实例，在Map结构中被视为两个键
var map = new Map();

var k1 = ['a'];
var k2 = ['a'];

map
.set(k1, 111)
.set(k2, 222);

map.get(k1) // 111
map.get(k2) // 222


// 如果Map的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map将其视为一个键，包括0和-0。另外，虽然NaN不严格相等于自身，但Map将其视为同一个键
let map3 = new Map();

map3.set(NaN, 123);
map3.get(NaN) // 123

map3.set(-0, 123);
map3.get(+0) // 123
















</script>
</body>
</html>