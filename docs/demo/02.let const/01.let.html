<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>let 命令</title>
</head>
<body>
<script>
{
	var a = 1;
	let b = 2;
}

console.log(a);
//console.log(b);   // Uncaught ReferenceError: b is not defined

/**
 * [for let 只在块级作用域有效]
 * @param  {[type]} let i             [description]
 * @return {[type]}     [description]
 */
for(let i = 0; i < 10; i++){
	//console.log(i);
};

//console.log(i); // Uncaught ReferenceError: b is not defined
/**
 	使用 var 声明的 i 在全局范围内都有效。所以每一次循环，新的i值都会覆盖旧值，导致最后输出的是最后一轮的i的值。
    如果使用let，声明的变量仅在块级作用域内有效
 */
var a = [];
for(let i = 0; i < 10; i++){
	a[i] = function (){
		console.log(i)
	};
};
a[6]();


console.log(foo); // undefined
console.log(bar); // Uncaught ReferenceError: bar is not defined

var foo = 2;
let bar = 3;


var tmp = 4;
if(true){
	tmp = 'abc';
	let tmp;
	// Uncaught ReferenceError: tmp is not defined
	// 存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错
	// ES6明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。
	// 在代码块内，使用let命令声明变量之前，该变量都是不可用的。
};


</script>
</body>
</html>
